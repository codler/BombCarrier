<!DOCTYPE HTML>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>BombCarrier v0.4.30</title>
		<link href='http://fonts.googleapis.com/css?family=Holtwood+One+SC' rel='stylesheet' type='text/css'>
		<link href='http://fonts.googleapis.com/css?family=Allan:700' rel='stylesheet' type='text/css'>
		<style type="text/css">
			body {
				background:#000;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}
		</style>
	</head>

	<body>
		<!--<script type="text/javascript" src="https://raw.github.com/mrdoob/three.js/dev/build/Three.js"></script>-->
	
		<script type="text/javascript" src="js/Three.js"></script>
		<script type="text/javascript" src="js/Detector.js"></script>
		<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="js/Stats.js"></script>

		<script type="text/javascript" src="fonts/helvetiker_regular.typeface.js"></script>

		<script type="text/javascript" src="js/jquery-1.6.4.min.js"></script>
		<script type="text/javascript" src="js/jquery.fittext.js"></script>

		<script type="text/javascript">
/**
 * @author Gustav Hjortsparre and Han Lin Yap
 * @license http://creativecommons.org/licenses/by-sa/3.0/
 * @package BombCarrier
 * @version 0.4.30 - 2011-10-02
 */

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

// == Begin Constants ==
var SCREEN_WIDTH  = window.innerWidth;
var SCREEN_HEIGHT = window.innerHeight;

var DEBUG = true;

// == End Constants ==
var container, stats;

var camera, scene, renderer;
var projector;
var loader;

var group;
var bombs;
var time = 0;

var mouse = { x: 0, y: 0 };

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;
/*
var keyMap = {
	38 : 'up1',
	87 : 'up2',
	40 : 'down1',
	83 : 'down2',
	37 : 'right1',
	65 : 'right2',
	39 : 'left1',
	68 : 'left2'
};

var keyPressed = {
	up1 : false,
	down1 : false,
	right1 : false,
	left1 : false,	
	up2 : false,
	down2 : false,
	right2 : false,
	left2 : false
};

var history = {};
*/
var player1, player2;

var debugElement;

var tileW = 116;
var tileH = 59;


var delta, time, oldTime;

var tileSystem;


var texture = {
	'map-a'        : 'textures/Dirt Block.png',
	'map-b'        : 'textures/Stone Block Tall.png',
	'map-c'        : 'textures/Water Block.png',
	'blue-block'   : 'textures/Gem Blue.png',
	'green-block'  : 'textures/Gem Green.png',
	'yellow-block' : 'textures/Gem Orange.png',
	'char-1'       : 'textures/Character Princess Girl.png',
	'bomb'         : 'textures/bomb.png',
	'explosion'    : 'textures/Explosion.png',
	'explosion2'   : 'textures/explosion2.png',
	'explosion3'   : 'textures/explosion3.png'
};





/*
Player class

map : texture
position : Vector3
*/
var PlayerClass = function( texture, position ) {
	this.history = []; // Players previous positions
	this.bombs   = [];
	this.width   = 80;
	this.height  = 100;

	this.sprite = new THREE.Sprite( { 
		map: texture || this.defaultTexture,
		useScreenCoordinates: false 
	} );


	// Collision area
	this.sprite.boundingMesh = new THREE.Mesh(
		new THREE.CubeGeometry(40, 40, 100, 1, 1, 1) 
		//,new THREE.MeshLambertMaterial( { color: 0xffffff } )
	);

	this.setPosition(position || new THREE.Vector3(0,0,0));
	this.setKeyPressed({
		up    :false,
		right :false,
		down  :false,
		left  :false,
		bomb  :false
	});

	this.collision = new THREE.CollisionSystem();
	
	
};
//PlayerClass.prototype.constructor = PlayerClass;

// Variable
PlayerClass.prototype.defaultTexture = THREE.ImageUtils.loadTexture( "textures/Character Princess Girl.png" );

/*
texture : texture
*/
PlayerClass.prototype.setTexture = function(texture) {
	this.sprite.map = texture;
};

/*
position : Vector3
*/
PlayerClass.prototype.setPosition = function(position) {
	this.setPositionX(position.x);
	this.setPositionY(position.y);
	this.setPositionZ(position.z);
};
/*
x : float
*/
PlayerClass.prototype.setPositionX = function(x) {
	this.sprite.position.x = x;
	this.sprite.boundingMesh.position.x = x;
};
/*
y : float
*/
PlayerClass.prototype.setPositionY = function(y) {
	this.sprite.position.y = y;
	this.sprite.boundingMesh.position.y = y - 40;
};
/*
z : float
*/
PlayerClass.prototype.setPositionZ = function(z) {
	this.sprite.position.z = z;
	this.sprite.boundingMesh.position.z = z;
};

/*
scale : Vector3
*/
PlayerClass.prototype.setScale = function(scale) {
	this.sprite.scale = scale;
};

/*
scene : Vector3
*/
PlayerClass.prototype.setScene = function(scene) {
	this.scene = scene;
	this.scene.addChild(this.sprite);
	this.scene.addChild(this.sprite.boundingMesh);
};

/*
collision : Object3d | Mesh
*/
PlayerClass.prototype.addCollision = function(collision) {
	this.collision.colliders.push( THREE.CollisionUtils.MeshOBB( collision.boundingMesh || collision ) );
};

/*
Store position
*/
PlayerClass.prototype.saveState = function() {
	this.history.push(this.sprite.position.clone());
	if (this.history.length > 5) {
		this.history.shift();
	}
};

/*
keys : { up, right, down, left }
*/
PlayerClass.prototype.setKeyPressed = function(keys) {
	this.keyPressed = keys;
};
/*
keys : { up, right, down, left }
*/
PlayerClass.prototype.setKeyCode = function(keys) {
	this.keyCode = keys;
};
/*
tileSystem : TileSystem
*/
PlayerClass.prototype.setTileSystem = function(tileSystem) {
	this.tileSystem = tileSystem;
};
PlayerClass.prototype.move = function(speed) {


	if (this.keyPressed.up) {
		this.setPositionY(this.sprite.position.y + speed);
	}
	if (this.keyPressed.down) {
		this.setPositionY(this.sprite.position.y - speed);
	}
	if (this.keyPressed.right) {
		this.setPositionX(this.sprite.position.x + speed);
	}
	if (this.keyPressed.left) {
		this.setPositionX(this.sprite.position.x - speed);
	}
};

PlayerClass.prototype.checkZIndex = function() {
	var z = -2 - (this.sprite.position.y - 200 - 10 )/ tileH * 2;

	z = z - (z - Math.floor(z)) / 2 + (z - Math.floor(z)) / 4;

	this.setPositionZ(z);
	return z;
};

PlayerClass.prototype.checkCollision = function() {
	var pop = false;
	var $this = this;
	var callback = function(side) {
		if (!pop) pop = $this.history.pop();
		if (side == 'l' || side == 'r') {
			$this.setPositionX(pop.x);
		} else if (side == 'n' || side == 's') {
			$this.setPositionY(pop.y);
		} else {
			$this.setPosition(pop);
		}
	};
	if (this.keyPressed.up) {
		this.checkCollisionItem(this.sprite.boundingMesh, callback, 'n');
	}
	if (this.keyPressed.down) {
		this.checkCollisionItem(this.sprite.boundingMesh, callback, 's');
	}
	if (this.keyPressed.right) {
		this.checkCollisionItem(this.sprite.boundingMesh, callback, 'r');
	}
	if (this.keyPressed.left) {
		this.checkCollisionItem(this.sprite.boundingMesh, callback, 'l');
	}
};

PlayerClass.prototype.checkCollisionItem = function(item, callback, side) {
	var direction;
	var position = item.position.clone();
	if (side == 'l') {
		direction = new THREE.Vector3(0,-1,0);
		position.addSelf(new THREE.Vector3(-20, 20 - 2, 0));
	} else if (side == 'r') {
		direction = new THREE.Vector3(0,-1,0);
		position.addSelf(new THREE.Vector3(20, 20 - 2, 0));
	} else if (side == 'n') {
		direction = new THREE.Vector3(1,0,0);
		position.addSelf(new THREE.Vector3(-20 + 2, 20, 0));
	} else if (side == 's') {
		direction = new THREE.Vector3(-1,0,0);
		position.addSelf(new THREE.Vector3(20 - 2, -20, 0));
	}

	var ray = new THREE.Ray( position, direction );
	var c = this.collision.rayCastNearest(ray);
	if (c && c.distance < 40 - 5) {
		callback(side);
	}
};

PlayerClass.prototype.handleBomb = function() {
	var availableBombs = this.bombs.length;
	for(bomb in this.bombs) {
		if ( this.bombs[bomb].exploded() ) {
			availableBombs--;
		}
	}
	if (this.keyPressed.bomb && availableBombs < 2) {
		var pos = this.sprite.position.clone().addSelf( new THREE.Vector3(0, -40, -0.5) );
		var tilePos = this.tileSystem.getTilePosition(pos.x + this.tileSystem.tileSize.width / 2, pos.y + 10);
		console.log([tilePos.x,tilePos.y]);

		// Check bomb isnt on same tile
		if (this.bombs.every(function (bomb) {
				return !(tilePos.x == bomb.position.x && tilePos.y == bomb.position.y);
			})
		) {
			pos = this.tileSystem.getPosition(tilePos.x, tilePos.y, pos.z);
	    	
	    	var bomb = new BombClass(tilePos, pos.addSelf( new THREE.Vector3(0, 10, 0) ) );
	    	bomb.setCollision( this.collision );

			bombs.addChild( bomb.animate );

			this.bombs.push(bomb);
			
		}
	}



	this.bombs.forEach(function (bomb) {
		bomb.update();
	});

	// Remove bomb
	if (this.bombs.length && this.bombs[0].expired()) {
		this.scene.removeObject( this.bombs.shift().animate );
	}
};

var TimeClass = function () {
	this.reset();
};
TimeClass.prototype.reset = function () {
	// In microseconds
	this.timeAlive = new Date().getTime();
	this.frame = 0;
};

/*
callback : function( timeOffsetFromFrameStart )

returns if it has elapsed
*/
TimeClass.prototype.elapse = function (frame, seconds, callback) {
	if (this.frame == frame) {
		if (new Date().getTime() > this.timeAlive + seconds * 1000) {
			callback( this.getElapse );
			this.frame++;
		}
	}
	return this.getFrameElapsed(frame);
};

TimeClass.prototype.getElapse = function () {
	// Returns seconds
	return (new Date().getTime() - this.timeAlive) / 1000;
};

TimeClass.prototype.getFrameElapsed = function (frame) {
	return this.frame > frame;
};

/*
timeAlive : Seconds
*/
var BombClass = function(tilePosition, position, timeAlive, firePower) {
	this.animate   = new THREE.Object3D();
	this.timeAlive = timeAlive || 5;
	this.position  = tilePosition;
	this.firePower = firePower || 2;

	this.sprite = new THREE.Sprite( { map: THREE.ImageUtils.loadTexture( texture.bomb ), useScreenCoordinates: false } );
	this.sprite.map.needsUpdate = true;

	this.sprite.position = position;
	this.sprite.scale = new THREE.Vector3(1.6,1.6,1);
	this.animate.addChild( this.sprite );

	this.sprite2 = new THREE.Sprite( { map: THREE.ImageUtils.loadTexture( texture.explosion2 ), useScreenCoordinates: false } );
	this.time = new TimeClass();
};

BombClass.prototype.setCollision = function (collision) {
	this.collision = collision;
};

BombClass.prototype.checkCollision = function (direction, distance) {
	var ray = new THREE.Ray( this.sprite.position.clone().addSelf(new THREE.Vector3(0, -20,0)), direction );
	var c = this.collision.rayCastNearest(ray);

	if (c && c.distance < distance ) {
		var tilePos = tileSystem.getTilePosition( c.mesh.position.x, c.mesh.position.y );
		console.log([tilePos, c.distance]);
		tileSystem.changeTile( tilePos.x, tilePos.y, 0 );

	}
};

BombClass.prototype.update = function () {
	var $this = this;
	if ( this.time.elapse(0, this.timeAlive - 2, function () {
		$this.sprite.map = THREE.ImageUtils.loadTexture( texture.explosion3 );
		$this.sprite.scale = new THREE.Vector3(1.3,1.3,1);
		$this.sprite.position.y += 30;

		$this.sprite2.position = $this.sprite.position;
		$this.sprite2.scale = $this.sprite.scale;
		$this.animate.addChild( $this.sprite2 );

		// collision with tile
		$this.checkCollision(new THREE.Vector3(0,1,0), tileSystem.tileSize.height * $this.firePower);
		$this.checkCollision(new THREE.Vector3(0,-1,0), tileSystem.tileSize.height * $this.firePower);
		$this.checkCollision(new THREE.Vector3(1,0,0), tileSystem.tileSize.width * $this.firePower);
		$this.checkCollision(new THREE.Vector3(-1,0,0), tileSystem.tileSize.width * $this.firePower);

	}) ) {

		this.sprite.opacity = 1 - ( this.time.getElapse() / this.timeAlive );
		this.sprite2.opacity = 1 - ( this.time.getElapse() / this.timeAlive );

	}
};

BombClass.prototype.expired = function () {
	return this.time.getElapse() > this.timeAlive;
};

BombClass.prototype.exploded = function () {
	return this.time.getElapse() > this.timeAlive - 2;
};



// x,y offset
// -800,-400
var TileSystem = function(x, y) {
	this.x       = x;
	this.y       = y;
	this.tiles   = new THREE.Object3D();
	this.players = [];
};

TileSystem.prototype.tileSize = {
	'width'  : 116,
	'height' : 59
};

TileSystem.prototype.tileInfo = {
	0 : {
		'name'       : 'map-a',
		'destroyable' : true
	},
	1 : {
		'name'       : 'map-b',
		'destroyable' : false
	},
	2 : {
		'name'       : 'map-c',
		'destroyable' : false
	},
	3 : {
		'name'       : 'blue-block',
		'destroyable' : true
	},
	4 : {
		'name'       : 'green-block',
		'destroyable' : true
	},
	5 : {
		'name'       : 'yellow-block',
		'destroyable' : true
	}
};

TileSystem.prototype.loadMap = function() {

	var times = function (s, i) {
		return (new Array(i+1)).join(s);
	};
	var repeat = function(s, i){
		var t = [];
		while(i--) t.push(s);
		return t;
	};

	var l = [];
	l.push( times('2 ', 15).trim() );
	l.push( '2 '.concat( times('0 ', 13) ).concat(2) );
	l.push( '2 '.concat( times('0 1 ', 6) ).concat('0 2') );
	l.push( '2 '.concat( times('3 ', 13) ).concat(2) );
	l.push( '2 '.concat( times('3 1 ', 6) ).concat('3 2') );
	l.push( '2 '.concat( times('4 ', 13) ).concat(2) );
	l.push( '2 '.concat( times('0 1 ', 6) ).concat('0 2') );
	l.push( '2 '.concat( times('4 ', 13) ).concat(2) );
	l.push( '2 '.concat( times('5 1 ', 6) ).concat('5 2') );
	l.push( '2 '.concat( times('5 ', 13) ).concat(2) );
	l.push( '2 '.concat( times('0 1 ', 6) ).concat('0 2') );
	l.push( '2 '.concat( times('0 ', 13) ).concat(2) );
	l.push( times('2 ', 15).trim() );
	l = l.join('\n');


	l = l.split('\n').reverse().map(function(x) { return x.split(' ')});
	/*
	var l = [];
	l.push( repeat(3, 15) );
	l.push( [3].concat( repeat(0, 13) ).concat(3) );
	l.push( [3,0,1,0,1,0,1,0,1,0,1,0,1,0,3] );
	l.push( [3].concat( repeat(0, 13) ).concat(3) );
	l.push( [3,0,1,0,1,0,1,0,1,0,1,0,1,0,3] );
	l.push( [3].concat( repeat(0, 13) ).concat(3) );
	l.push( [3,0,1,0,1,0,1,0,1,0,1,0,1,0,3] );
	l.push( [3].concat( repeat(0, 13) ).concat(3) );
	l.push( [3,0,1,0,1,0,1,0,1,0,1,0,1,0,3] );
	l.push( [3].concat( repeat(0, 13) ).concat(3) );
	l.push( repeat(3, 15) );
*/

	var level = l;

	this.level      = level;
	this.sizeWidth  = this.level[0].length;
	this.sizeHeight = this.level.length;

	// Remapping
	for (var x = 0; x < this.sizeWidth; x++) {
		for (var y = 0; y < this.sizeHeight; y++) {
			this.level[y][x] = {
				type : this.level[y][x]
			};
		}
	}

	for (var x = 0; x < this.sizeWidth; x++) {
		for (var y = 0; y < this.sizeHeight; y++) {
			// Times 2 means one TileSizeY equals 2z
			var z = this.sizeWidth - y * 2;
			var tileType = this.level[y][x].type;
			var tileTexture = this.tileInfo[ tileType ].name;

			var sprite = new THREE.Sprite( { 
				map: texture[tileTexture], 
				useScreenCoordinates: false 
			} );

			

			// Collision on tileType 1,2
			if (tileType != 0)  {
				
				z++; // IMPORTANT, do not move or remove!
				
				// Collision area
				sprite.boundingMesh = new THREE.Mesh(
					new THREE.CubeGeometry(120, 60, 100, 1, 1, 1) 
					//,new THREE.MeshLambertMaterial( { color: 0xffccff } )
				);

				sprite.boundingMesh.position.set(
					x * this.tileSize.width + this.x,
					y * this.tileSize.height + this.y + 10,
					z
				);
				
				// Register collision to players
				for (var p = 0; p < this.players.length; p++) {
					this.players[p].addCollision(sprite);
				}

				this.tiles.addChild( sprite.boundingMesh );

			}

			sprite.position.set(
				x * this.tileSize.width + this.x,
				y * this.tileSize.height + this.y,
				z
			);

			this.level[y][x].sprite = sprite;

			this.tiles.addChild( sprite );
		}
	}

};

TileSystem.prototype.changeTile = function( tileX, tileY, tileType, force) {
	force = force || false;
	var t =  texture[ this.tileInfo[ tileType ].name ];
	console.log(this.tileInfo[ this.level[tileY][tileX].type ].name);
	if (force || (tileType == 0 && this.tileInfo[ this.level[tileY][tileX].type ].destroyable)) {
		// TODO : Replace this. This is a temporary fix to "remove" object.
		this.level[tileY][tileX].sprite.boundingMesh.position.y -= 10000;
		this.level[tileY][tileX].sprite.map = THREE.ImageUtils.loadTexture( t );
		this.level[tileY][tileX].sprite.map.needsUpdate = true;
		return true;
	}
	return false;
};

/*
player : PlayerClass
*/
TileSystem.prototype.addPlayer = function(player) {
	this.players.push(player);
};

TileSystem.prototype.setScene = function(scene) {
	this.scene = scene;
	this.scene.addChild(this.tiles);
};

TileSystem.prototype.getPosition = function(tileX, tileY, z) {
	return new THREE.Vector3(
		tileX * this.tileSize.width + this.x, 
		tileY * this.tileSize.height + this.y, 
		z || 0
	);
};

TileSystem.prototype.getTilePosition = function(x, y) {
	return {
		x: Math.floor( (x - this.x) / this.tileSize.width ),
		y: Math.floor( (y - this.y) / this.tileSize.height )
	};
};





// Initialize core - canvas, camera, scene, debuginfo
function init_core() {

	container = $('<div>');
	$('body').append( container );

	projector = new THREE.Projector();

	camera = new THREE.Camera( 
		60, 							// FOV, field of view
		SCREEN_WIDTH / SCREEN_HEIGHT, 	// Aspect ratio
		1, 								// Near
		10000 							// Far
	);
	camera.position.z = 1000;

	loader = new THREE.Loader( true );

	scene = new THREE.Scene();

	// renderer
	renderer = new THREE.WebGLRenderer();
	renderer.setClearColorHex( 0x000000, 1 );
	renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

	container.append( renderer.domElement );

	var fixAspectRatio = function() {
		SCREEN_WIDTH = window.innerWidth;
		SCREEN_HEIGHT = window.innerHeight;

		// Fix aspect ratio
		if (SCREEN_WIDTH / SCREEN_HEIGHT < 1.8) {
			SCREEN_HEIGHT = SCREEN_WIDTH * 0.5;
			$('canvas:first').height(SCREEN_HEIGHT);
		} else {
			$('canvas:first').height('100%');
		}

		renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
		camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
		camera.updateProjectionMatrix();
	};
	
	fixAspectRatio();
	
	// Event listener
	$(window).resize(fixAspectRatio);

	container.mousemove( onDocumentMouseMove );

	// Debug box
	if (DEBUG) {

		debugElement = $('<div>').css({
			'background-color' : '#ccc',
			'margin-left' : 80,
			'opacity' : 0.5,
			'position' : 'absolute',
			'top' : 0,
			'z-index' : 1001
		});
		container.append( debugElement );

	}

	// Stats - FPS viewer
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.zIndex = 1000;
	container.append( stats.domElement );
}

function intro_scene() {
		var intro_scene = $('<div>').css({
			'background-image' : 'url(textures/diaglog-box.png)',
			'background-size' : '100% 100%',
			'font-family' : "'Holtwood One SC', serif",
			'position' : 'absolute',
			'top' : 0,
			'left' : 0,
			'z-index' : 101,
			'text-align' : 'center',
			'width' : '100%',
			'height' : '100%'
		});

		var bomb_title = $('<h1>')
			.html('B<img src="textures/logoBomb.png" style="width:12%;"/>mb')
			.css({
				'color' : '#fff',
				'line-height' : 1,
				'padding' : 0,
				'margin' : 0,
				'width' : '100%'
			});

		var carrier_title = $('<h1>')
			.text('Carrier')
			.css({
				'padding' : 0,
				'line-height' : 1,
				'margin' : 0,
				'width' : '100%'
			});

		var meny = $('<h1>')
			.html('Play')
			.css({
				'cursor' : 'pointer',
				'width' : '100%'
			});
			
		// Start game
		$(meny).click(function() {
				play_scene();
				intro_scene.remove();
			});

		$(meny).mouseover(function() {
			$(this).css({
				'color' : '#FFF'
			});
		});

		$(meny).mouseout(function() {
			$(this).css({
				'color' : '#000'
			});
		});

		var intro_scene_inner = $('<div>').css({
			'margin' : '0 auto'
		});

		intro_scene_inner.append( bomb_title );
		intro_scene_inner.append( carrier_title );
		intro_scene_inner.append( meny );

		intro_scene.append( intro_scene_inner );

		container.append( intro_scene );

		// Fix aspect ratio
		if (intro_scene.width() / intro_scene.height() > 1.8) {
			intro_scene_inner.width(intro_scene.height() * 1.8);
		}

		$(bomb_title).fitText( 0.6 );
		$(carrier_title).fitText( 0.9 );
		$(meny).fitText( 1.3 );
}

function play_scene() {

	// Event listener
	$(document).keydown( onKeyDown );
	$(document).keyup( onKeyUp );

	init();
	animate();
}


function init() {
	var amount = 15*13;
	var mapA   = THREE.ImageUtils.loadTexture( "textures/Dirt Block.png" );
	var mapB   = THREE.ImageUtils.loadTexture( "textures/Stone Block Tall.png" );
	var mapC   = THREE.ImageUtils.loadTexture( "textures/Water Block.png" );
	var char1  = THREE.ImageUtils.loadTexture( "textures/Character Princess Girl.png" );




	player1 = new PlayerClass( "textures/Character Princess Girl.png", new THREE.Vector3(
		0 * tileW - 200 + 0,
		0 * tileH - 200 + 280,
		15 + 2
	) );
	player1.setScene(scene);
	player1.setScale(new THREE.Vector3(1,1.5,1));

	player1.setKeyCode({
		87 : 'up', // w
		83 : 'down', // s
		68 : 'right', // d
		65 : 'left', // a
		16 : 'bomb', // shift
		86 : 'explosion'
	});

	player2 = new PlayerClass( "textures/Character Horn Girl.png", new THREE.Vector3(
		0 * tileW - 100 + 90,
		0 * tileH - 200 + 160,
		15 + 2
	) );
	player2.setScene(scene);
	player2.setScale(new THREE.Vector3(1,1.5,1));

	player2.setKeyCode({
		38 : 'up', // arrow up
		40 : 'down', // arrow down
		39 : 'right', // arrow right
		37 : 'left', // arrow left
		32 : 'bomb' // space
	});

	//player1.addCollision(player2.sprite);
	//player2.addCollision(player1.sprite);

	tileSystem = new TileSystem( -800, -400 );
	tileSystem.addPlayer(player1);
	tileSystem.addPlayer(player2);
	tileSystem.loadMap();
	tileSystem.setScene(scene);

	player1.setTileSystem(tileSystem);
	player2.setTileSystem(tileSystem);

	player1.setPosition( tileSystem.getPosition(1,1).addSelf(new THREE.Vector3(0, 40, 0)) );
	player2.setPosition( tileSystem.getPosition(13,11).addSelf(new THREE.Vector3(0, 40, 0)) );


/*
	group = new THREE.Object3D();

	var level1 = [
		[mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC],
		
		[mapC, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapC],
		[mapC, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapC],
		
		[mapC, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapC],
		[mapC, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapC],
		
		[mapC, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapC],
		[mapC, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapC],
		
		[mapC, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapC],
		[mapC, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapC],

		[mapC, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapC],
		[mapC, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapB, mapA, mapC],

		[mapC, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapA, mapC],

		[mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC, mapC]
	];
	var level = level1;

	for( var a = 0; a < amount; a++ ) {

		var z = 15 - Math.floor(a/15) * 2;

		var map = level[Math.floor(a/15)][a%15];
		var sprite = new THREE.Sprite( { map: map, useScreenCoordinates: false } );

		if (sprite.map == mapB || sprite.map == mapC) {
			z++;
			// Collision area
			sprite.boundingMesh = new THREE.Mesh(
				new THREE.CubeGeometry(120, 60, 100, 1, 1, 1) 
				//,new THREE.MeshLambertMaterial( { color: 0xffccff } )
			);

			sprite.boundingMesh.position.set( a%15 * tileW - 800,
		                     Math.floor(a/15) * tileH - 400 + 10,
		                     z - 20);

			group.addChild( sprite.boundingMesh );
			player1.addCollision(sprite);
			player2.addCollision(sprite);
		}

		sprite.position.set( a%15 * tileW - 800,
		                     Math.floor(a/15) * tileH - 400,
		                     z);

		//sprite.position.normalize();
		//sprite.position.multiplyScalar( radius );
		
		
		group.addChild( sprite );
	}

	scene.addChild( group );*/



	bombs = new THREE.Object3D();
	scene.addChild( bombs );

	


	// Inline text
	/*var text3d = new THREE.TextGeometry( 'testar text', {

					size: 80,
					height: 20,
					curveSegments: 2,
					font: "helvetiker"

				});

				text3d.computeBoundingBox();
				var centerOffset = -0.5 * ( text3d.boundingBox.x[ 1 ] - text3d.boundingBox.x[ 0 ] );

                var textMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: false } );
                text = new THREE.Mesh( text3d, textMaterial );

                text.doubleSided = false;

                text.position.set( 0, 100, 0 );

				text.overdraw = true;

				parent = new THREE.Object3D();
                parent.addChild( text );

				scene.addObject( parent );*/


	//THREE.Collisions.colliders.push(spriteChar2);

	// add 2d-sprites
	/*
	sprite = new THREE.Sprite( { map: mapA, alignment:THREE.SpriteAlignment.topLeft } );
	sprite.position.set( 100, 100, 0 );
	sprite.opacity = 0.25;
	scene.addChild( sprite );

	sprite = new THREE.Sprite( { map: mapA, alignment:THREE.SpriteAlignment.topLeft } );
	sprite.position.set( 150, 150, 2 );
	sprite.opacity = 0.5;
	scene.addChild( sprite );

	sprite = new THREE.Sprite( { map: mapA, alignment:THREE.SpriteAlignment.topLeft } );
	sprite.position.set( 200, 200, 3 );
	sprite.opacity = 1;
	scene.addChild( sprite );
	*/

	

}



function animate() {

	requestAnimationFrame( animate );

	render();
	stats.update();

}


function render() {
	/*
	for ( var c = 0; c < group.children.length; c++ ) {

		var sprite = group.children[ c ];
		var scale = Math.sin( time + sprite.position.x * 0.01 ) * 0.3 + 1.0;

		sprite.rotation += 0.1 * ( c / group.children.length );
		sprite.scale.set( scale, scale, 1.0 );
		sprite.opacity = Math.sin( time + sprite.position.x * 0.01 ) * 0.4 + 0.6;
	}

	group.rotation.x = time * 0.5;
	group.rotation.y = time * 0.75;
	group.rotation.z = time * 1.0;

	time += 0.02;
	*/

	
	if (DEBUG) {
		var s = [
			//'Mouse - X:' + mouse.x.toFixed(2) + ' Y:' + mouse.y.toFixed(2),
			'Mouse - ' + JSON.stringify(mouse),
			'camera - ' + JSON.stringify(camera.position),
			'Spritechar1 - ' + JSON.stringify(player1.sprite.position),
			'Spritechar2 - ' + JSON.stringify(player2.sprite.position),
			'distance - ' + JSON.stringify(player1.sprite.position.clone().subSelf(player2.sprite.position))
		];

		var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
		projector.unprojectVector( vector, camera );

		var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

		var c = player1.collision.rayCastNearest( ray );

		if ( c ) {

			s.push('Mouse collision distance - ' + c.distance.toFixed(2));
			s.push('Mouse collision item position (z+20)- ' + JSON.stringify(c.mesh.position));

		}

		debugElement.html (s.join('<br/>'));
	}	

	//player1.sprite.boundingMesh.materials[0].color = new THREE.Color(0xffffff);
	//player2.sprite.boundingMesh.materials[0].color = new THREE.Color(0xffffff);

	if ( ! oldTime ) oldTime = new Date().getTime();

	time = new Date().getTime();
	delta = 0.15 * ( time - oldTime );
	oldTime = time;

	player1.saveState();
	player1.move(delta);
	player1.checkCollision();
	player1.checkZIndex();
	player1.handleBomb();

	player2.saveState();
	player2.move(delta);
	player2.checkCollision();
	player2.checkZIndex();
	player2.handleBomb();

	renderer.render( scene, camera );

}

function log( text ) {

	var e = document.getElementById("log");
	e.innerHTML = text + "<br/>" + e.innerHTML;

}

function onDocumentMouseMove( event ) {

	event.preventDefault();	
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

};

function onKeyDown(a) {
    var a = a.keyCode;
    /*
    if (a in keyMap) {
    	keyPressed[keyMap[a]] = true;
    }*/

    if (a in player1.keyCode) {
    	player1.keyPressed[player1.keyCode[a]] = true;

    }
    if (a in player2.keyCode) {
    	player2.keyPressed[player2.keyCode[a]] = true;


    }

}
function onKeyUp(a) {
    a = a.keyCode;
    /*
    if (a in keyMap) {
    	keyPressed[keyMap[a]] = false;
    }*/

    if (a in player1.keyCode) {
    	player1.keyPressed[player1.keyCode[a]] = false;
    }
    if (a in player2.keyCode) {
    	player2.keyPressed[player2.keyCode[a]] = false;
    }
}

jQuery(function ($) {
	init_core();
	intro_scene();
});
		</script>
	</body>
</html>
